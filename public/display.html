<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pong - LED Display</title>
    <style>
      /* ... CSS bleibt gleich ... */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #000;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw;
      }

      canvas {
        display: block;
        background: #000;
      }
    </style>
  </head>
  <body>
    <canvas id="displayCanvas"></canvas>

    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script>
      // === KONFIGURATION ===
      const WEBSOCKET_URL =
        "https://your-railway-app.railway.app" || "http://localhost:3000";
      // ====================

      const canvas = document.getElementById("displayCanvas");
      const ctx = canvas.getContext("2d");

      const TOTAL_WIDTH = 10368;
      const TOTAL_HEIGHT = 1536;
      const LEFT_SCREEN_WIDTH = 3968;
      const RIGHT_SCREEN_WIDTH = 6400;
      const ASPECT_RATIO = TOTAL_WIDTH / TOTAL_HEIGHT;

      canvas.width = TOTAL_WIDTH;
      canvas.height = TOTAL_HEIGHT;

      function scaleCanvas() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const windowRatio = windowWidth / windowHeight;

        let scale;
        if (windowRatio > ASPECT_RATIO) {
          scale = windowHeight / TOTAL_HEIGHT;
        } else {
          scale = windowWidth / TOTAL_WIDTH;
        }

        canvas.style.width = TOTAL_WIDTH * scale + "px";
        canvas.style.height = TOTAL_HEIGHT * scale + "px";
      }

      window.addEventListener("resize", scaleCanvas);
      scaleCanvas();

      const socket = io(WEBSOCKET_URL, {
        transports: ["websocket", "polling"],
        reconnection: true,
        reconnectionAttempts: 10,
        reconnectionDelay: 1000,
      });

      let gameState = null;
      let connected = false;

      socket.on("connect", () => {
        connected = true;
        console.log("Display verbunden mit Server");
      });

      socket.on("disconnect", () => {
        connected = false;
      });

      socket.on("gameState", (data) => {
        gameState = data;
      });

      function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, TOTAL_WIDTH, TOTAL_HEIGHT);

        if (!gameState) {
          ctx.font = "bold 200px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = connected ? "#00ff00" : "#ff0000";
          ctx.fillText(
            connected
              ? "Warte auf Spieler..."
              : "Keine Verbindung zum Server",
            TOTAL_WIDTH / 2,
            TOTAL_HEIGHT / 2
          );
          return;
        }

        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(LEFT_SCREEN_WIDTH, 0);
        ctx.lineTo(LEFT_SCREEN_WIDTH, TOTAL_HEIGHT);
        ctx.stroke();

        const scaleX = LEFT_SCREEN_WIDTH / gameState.canvasWidth;
        const scaleY = TOTAL_HEIGHT / gameState.canvasHeight;

        ctx.strokeStyle = "#333";
        ctx.lineWidth = 5;
        ctx.setLineDash([60, 40]);
        ctx.beginPath();
        ctx.moveTo(LEFT_SCREEN_WIDTH / 2, 0);
        ctx.lineTo(LEFT_SCREEN_WIDTH / 2, TOTAL_HEIGHT);
        ctx.stroke();
        ctx.setLineDash([]);

        const PADDLE_WIDTH = 15 * scaleX;
        const PADDLE_HEIGHT = 100 * scaleY;
        const BALL_SIZE = 15 * Math.min(scaleX, scaleY);

        ctx.fillStyle = "#00ff00";
        ctx.fillRect(
          50 * scaleX,
          gameState.playerY * scaleY,
          PADDLE_WIDTH,
          PADDLE_HEIGHT
        );

        ctx.fillStyle = "#ff0000";
        ctx.fillRect(
          (gameState.canvasWidth - 50 - 15) * scaleX,
          gameState.aiY * scaleY,
          PADDLE_WIDTH,
          PADDLE_HEIGHT
        );

        ctx.fillStyle = "#fff";
        ctx.shadowBlur = 30;
        ctx.shadowColor = "#fff";
        ctx.fillRect(
          gameState.ballX * scaleX,
          gameState.ballY * scaleY,
          BALL_SIZE,
          BALL_SIZE
        );
        ctx.shadowBlur = 0;

        const rightCenterX = LEFT_SCREEN_WIDTH + RIGHT_SCREEN_WIDTH / 2;
        const centerY = TOTAL_HEIGHT / 2;

        ctx.font = "bold 600px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.fillStyle = "#00ff00";
        ctx.fillText(
          gameState.playerScore,
          rightCenterX - 800,
          centerY - 200
        );

        ctx.fillStyle = "#666";
        ctx.font = "bold 400px Arial";
        ctx.fillText(":", rightCenterX, centerY - 200);

        ctx.fillStyle = "#ff0000";
        ctx.font = "bold 600px Arial";
        ctx.fillText(gameState.aiScore, rightCenterX + 800, centerY - 200);

        ctx.font = "bold 150px Arial";
        ctx.fillStyle = "#00ff00";
        ctx.fillText("PLAYER", rightCenterX - 800, centerY + 300);
        ctx.fillStyle = "#ff0000";
        ctx.fillText("AI", rightCenterX + 800, centerY + 300);

        const time = Date.now();
        if (Math.floor(time / 500) % 2 === 0) {
          ctx.font = "bold 120px Arial";
          ctx.fillStyle = "#ff0000";
          ctx.fillText("● LIVE", rightCenterX, centerY + 600);
        }
      }

      function animationLoop() {
        draw();
        requestAnimationFrame(animationLoop);
      }

      function enterFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
          elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) {
          elem.webkitRequestFullscreen();
        }
      }

      document.addEventListener("click", () => {
        if (!document.fullscreenElement) {
          enterFullscreen();
        }
      });

      window.addEventListener("load", () => {
        setTimeout(enterFullscreen, 500);
      });

      animationLoop();
    </script>
  </body>
</html>